{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/ExponentialNoError.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Compound\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\ncontract ExponentialNoError {\n    uint constant expScale = 1e18;\n    uint constant doubleScale = 1e36;\n    uint constant halfExpScale = expScale/2;\n    uint constant mantissaOne = expScale;\n\n    struct Exp {\n        uint mantissa;\n    }\n\n    struct Double {\n        uint mantissa;\n    }\n\n    /**\n     * @dev Truncates the given exp to a whole number value.\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\n     */\n    function truncate(Exp memory exp) pure internal returns (uint) {\n        // Note: We are not using careful math here as we're performing a division that cannot fail\n        return exp.mantissa / expScale;\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n     */\n    function mul_ScalarTruncate(Exp memory a, uint scalar) pure internal returns (uint) {\n        Exp memory product = mul_(a, scalar);\n        return truncate(product);\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n     */\n    function mul_ScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (uint) {\n        Exp memory product = mul_(a, scalar);\n        return add_(truncate(product), addend);\n    }\n\n    /**\n     * @dev Checks if first Exp is less than second Exp.\n     */\n    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n        return left.mantissa < right.mantissa;\n    }\n\n    /**\n     * @dev Checks if left Exp <= right Exp.\n     */\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n        return left.mantissa <= right.mantissa;\n    }\n\n    /**\n     * @dev Checks if left Exp > right Exp.\n     */\n    function greaterThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n        return left.mantissa > right.mantissa;\n    }\n\n    /**\n     * @dev returns true if Exp is exactly zero\n     */\n    function isZeroExp(Exp memory value) pure internal returns (bool) {\n        return value.mantissa == 0;\n    }\n\n    function safe224(uint n, string memory errorMessage) pure internal returns (uint224) {\n        require(n < 2**224, errorMessage);\n        return uint224(n);\n    }\n\n    function safe32(uint n, string memory errorMessage) pure internal returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    function add_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\n        return Exp({mantissa: add_(a.mantissa, b.mantissa)});\n    }\n\n    function add_(Double memory a, Double memory b) pure internal returns (Double memory) {\n        return Double({mantissa: add_(a.mantissa, b.mantissa)});\n    }\n\n    function add_(uint a, uint b) pure internal returns (uint) {\n        return a + b;\n    }\n\n    function sub_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\n        return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\n    }\n\n    function sub_(Double memory a, Double memory b) pure internal returns (Double memory) {\n        return Double({mantissa: sub_(a.mantissa, b.mantissa)});\n    }\n\n    function sub_(uint a, uint b) pure internal returns (uint) {\n        return a - b;\n    }\n\n    function mul_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\n        return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\n    }\n\n    function mul_(Exp memory a, uint b) pure internal returns (Exp memory) {\n        return Exp({mantissa: mul_(a.mantissa, b)});\n    }\n\n    function mul_(uint a, Exp memory b) pure internal returns (uint) {\n        return mul_(a, b.mantissa) / expScale;\n    }\n\n    function mul_(Double memory a, Double memory b) pure internal returns (Double memory) {\n        return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\n    }\n\n    function mul_(Double memory a, uint b) pure internal returns (Double memory) {\n        return Double({mantissa: mul_(a.mantissa, b)});\n    }\n\n    function mul_(uint a, Double memory b) pure internal returns (uint) {\n        return mul_(a, b.mantissa) / doubleScale;\n    }\n\n    function mul_(uint a, uint b) pure internal returns (uint) {\n        return a * b;\n    }\n\n    function div_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\n        return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\n    }\n\n    function div_(Exp memory a, uint b) pure internal returns (Exp memory) {\n        return Exp({mantissa: div_(a.mantissa, b)});\n    }\n\n    function div_(uint a, Exp memory b) pure internal returns (uint) {\n        return div_(mul_(a, expScale), b.mantissa);\n    }\n\n    function div_(Double memory a, Double memory b) pure internal returns (Double memory) {\n        return Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\n    }\n\n    function div_(Double memory a, uint b) pure internal returns (Double memory) {\n        return Double({mantissa: div_(a.mantissa, b)});\n    }\n\n    function div_(uint a, Double memory b) pure internal returns (uint) {\n        return div_(mul_(a, doubleScale), b.mantissa);\n    }\n\n    function div_(uint a, uint b) pure internal returns (uint) {\n        return a / b;\n    }\n\n    function fraction(uint a, uint b) pure internal returns (Double memory) {\n        return Double({mantissa: div_(mul_(a, doubleScale), b)});\n    }\n}\n"
    },
    "contracts/Oracles/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\ninterface AggregatorV3Interface {\n\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n\t// getRoundData and latestRoundData should both raise \"No data present\"\n\t// if they do not have data to report, instead of returning unset values\n\t// which could be misinterpreted as actual reported values.\n\tfunction getRoundData(uint80 _roundId) external view \n\t\treturns (\n\t\t\tuint80 roundId,\n\t\t\tint256 answer,\n\t\t\tuint256 startedAt,\n\t\t\tuint256 updatedAt,\n\t\t\tuint80 answeredInRound\n\t\t);\n\n\tfunction latestRoundData() external view\n\t\treturns (\n\t\t\tuint80 roundId,\n\t\t\tint256 answer,\n\t\t\tuint256 startedAt,\n\t\t\tuint256 updatedAt,\n\t\t\tuint80 answeredInRound\n\t\t);\n}\n\ninterface AggregatorValidatorInterface {\n\tfunction validate(uint256 previousRoundId,\n\t\t\tint256 previousAnswer,\n\t\t\tuint256 currentRoundId,\n\t\t\tint256 currentAnswer) external returns (bool);\n}\n"
    },
    "contracts/Oracles/interfaces/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\ninterface ICToken {\n    function underlying() external view returns (address);\n    function exchangeRateCurrent() external returns (uint);\n    function exchangeRateStored() external view returns (uint);\n    function isCToken() external view returns (bool);\n}\n\ninterface IPriceOracle {\n    function isPriceOracle() external view returns (bool);\n    function getAssetPrice(address asset) external view returns (uint);\n    function getAssetPriceUpdateTimestamp(address asset) external view returns (uint);\n    function getUnderlyingPrice(ICToken cToken) external view returns (uint);\n    function getUnderlyingPriceUpdateTimestamp(address cToken) external view returns (uint);\n}\n"
    },
    "contracts/Oracles/TonpoundPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./UniswapConfigV2.sol\";\nimport \"../ExponentialNoError.sol\";\nimport \"./interfaces/IPriceOracle.sol\";\nimport \"./interfaces/AggregatorV3Interface.sol\";\n\n\ncontract TonpoundPriceOracle is ExponentialNoError, UniswapConfigV2 {\n    \n    struct PriceData {\n        uint248 price;\n        bool failoverActive;\n    }\n\n    /// @notice ChainLink Feed address by underlying address\n    mapping(address => address) public chainLinkFeeds;\n\n    /// @notice ChainLink Feed decimals by underlying address\n    mapping(address => uint8) public chainLinkFeedDecimals;\n\n    /// @notice assets decimals by underlying address \n    mapping(address => uint8) public assetsDecimals;\n\n\n    /// @notice Prices provided by reporters using uniswap TWAP\n    mapping(bytes32 => PriceData) public prices;\n\n    /// @notice The number of wei in 1 ETH\n    uint256 public constant ETH_BASE_UNIT = 1e18;\n\n    /// @notice A common scaling factor to maintain precision\n    uint256 public constant EXP_SCALE = 1e18;\n\n    /// @notice The highest ratio of the new price to the anchor price that will still trigger the price to be updated\n    uint256 public immutable upperBoundAnchorRatio;\n\n    /// @notice The lowest ratio of the new price to the anchor price that will still trigger the price to be updated\n    uint256 public immutable lowerBoundAnchorRatio;\n\n\n    bytes32 internal constant ETH_HASH = keccak256(\"ETH\");\n\n    /// @notice chainlink price feed ETH / USD\n    AggregatorV3Interface public immutable baseAssetFeed;\n\n    /// @notice denominator to scale price from chainlink price feed\n    uint8 internal immutable baseAssetFeedDenominator;\n\n    /// @notice The time interval to search for TWAPs when calling the Uniswap V3 observe function\n    uint32 public immutable anchorPeriod;\n\n    /// @notice The event emitted when new prices are posted but the stored price is not updated due to the anchor\n    event PriceGuarded(\n        bytes32 indexed symbolHash,\n        uint256 reporterPrice,\n        uint256 anchorPrice\n    );\n\n    /// @notice The event emitted when the stored price is updated\n    event PriceUpdated(bytes32 indexed symbolHash, uint256 price);\n\n    /// @notice The event emitted when failover is activated\n    event FailoverActivated(bytes32 indexed symbolHash);\n\n    /// @notice The event emitted when failover is deactivated\n    event FailoverDeactivated(bytes32 indexed symbolHash);\n\n    /// @notice The event emitted when new PriceFeed added (updated)\n    event NewFeedForAsset(address indexed asset, address oldFeed, address newFeed);\n\n\n    /**\n     * @notice Construct a Uniswap anchored view for a set of token configurations\n     * @dev Note that to avoid immature TWAPs, the system must run for at least a single anchorPeriod before using.\n     *      NOTE: Reported prices are set to 1 during construction. We assume that this contract will not be voted in by\n     *      governance until prices have been updated through `validate` for each TokenConfig.\n     * @param anchorPeriod_ The minimum amount of time required for the old Uniswap price accumulator to be replaced\n     * @param upperBoundAnchorRatio_ The highest ratio of the new price to the anchor price that will still trigger the price to be updated\n     * @param lowerBoundAnchorRatio_ The lowest ratio of the new price to the anchor price that will still trigger the price to be updated\n     */\n    constructor(\n        uint32 anchorPeriod_,\n        uint256 upperBoundAnchorRatio_,\n        uint256 lowerBoundAnchorRatio_,\n        address baseUnderlying,\n        AggregatorV3Interface baseAssetFeed_\n    ) {\n        require(anchorPeriod_ > 0, \"period\");\n        anchorPeriod = anchorPeriod_;\n\n        require(lowerBoundAnchorRatio_ < upperBoundAnchorRatio_, \"bounds\");\n        upperBoundAnchorRatio = upperBoundAnchorRatio_;\n        lowerBoundAnchorRatio = lowerBoundAnchorRatio_;\n\n        require(baseUnderlying != address(0), \"underlying\");\n        // no need to check baseAssetFeed_ against address(0)\n        baseAssetFeed = baseAssetFeed_;\n        uint8 priceFeedDecimals_ = baseAssetFeed_.decimals();\n        baseAssetFeedDenominator = priceFeedDecimals_ - 6;\n        _setPriceFeedForUnderlyingInternal(baseUnderlying, address(baseAssetFeed_), priceFeedDecimals_);\n    }\n\n    /// @notice Get the underlying price of a cToken asset\n    /// @param cToken The cToken to get the underlying price of\n    /// @return The underlying asset price mantissa (scaled by 1e(36 - assetDecimals)).\n    ///         Zero means the price is unavailable.\n    function getUnderlyingPrice(ICToken cToken) public view returns (uint) {\n        address asset = cToken.underlying();\n        if (hasFeedForAsset(asset)) {\n            return _getOraclePriceForAssetInternal(asset);\n        } else if (hasTwapForAsset(asset)) {\n            return _getTwapPriceForAssetInternal(address(cToken));\n        } else {\n            return 0;\n        }\n    }\n\n    /// @notice Get the official price for a symbol\n    /// @param symbol The symbol to fetch the price of\n    /// @return Price denominated in USD, with 6 decimals\n    function price(string calldata symbol) external view returns (uint256) {\n        TokenConfig memory config = getTokenConfigBySymbol(symbol);\n        return priceInternal(config);\n    }\n\n    function priceInternal(TokenConfig memory config)\n        internal\n        view\n        returns (uint256)\n    {\n        if (config.priceSource == PriceSource.REPORTER) {\n            return prices[config.symbolHash].price;\n        } else if (config.priceSource == PriceSource.FIXED_USD) {\n            return config.fixedPrice;\n        } else {\n            // config.priceSource == PriceSource.FIXED_ETH\n            uint256 usdPerEth = prices[ETH_HASH].price;\n            require(usdPerEth > 0, \"ETH price not set\");\n            return FullMath.mulDiv(usdPerEth, config.fixedPrice, ETH_BASE_UNIT);\n        }\n    }\n\n    /// @notice Get the underlying price of a cToken, in the format expected by the Comptroller.\n    /// @dev Implements the PriceOracle interface for Compound v2.\n    /// @param cToken The cToken address for price retrieval\n    /// @return Price denominated in USD for the given cToken address, in the format expected by the Comptroller.\n    function _getTwapPriceForAssetInternal(address cToken)\n        internal\n        view\n        returns (uint256)\n    {\n        TokenConfig memory config = getTokenConfigByCToken(cToken);\n        // Comptroller needs prices in the format: ${raw price} * 1e36 / baseUnit\n        // The baseUnit of an asset is the amount of the smallest denomination of that asset per whole.\n        // For example, the baseUnit of ETH is 1e18.\n        // Since the prices in this view have 6 decimals, we must scale them by 1e(36 - 6)/baseUnit\n        return FullMath.mulDiv(1e30, priceInternal(config), config.baseUnit);\n    }\n\n\n    /// @notice This is called by the reporter whenever a new price is posted on-chain\n    /// @dev called by AccessControlledOffchainAggregator\n    /// @param currentAnswer the price\n    /// @return valid bool\n    function validate(\n        uint256, /* previousRoundId */\n        int256, /* previousAnswer */\n        uint256, /* currentRoundId */\n        int256 currentAnswer\n    ) external returns (bool valid) {\n        // NOTE: We don't do any access control on msg.sender here. The access control is done in getTokenConfigByReporter,\n        // which will REVERT if an unauthorized address is passed.\n        TokenConfig memory config = getTokenConfigByReporter(msg.sender);\n        uint256 reportedPrice = convertReportedPrice(config, currentAnswer);\n        uint256 anchorPrice = calculateAnchorPriceFromEthPrice(config);\n\n        PriceData memory priceData = prices[config.symbolHash];\n        if (priceData.failoverActive) {\n            require(anchorPrice < 2**248, \"Anchor too big\");\n            prices[config.symbolHash].price = uint248(anchorPrice);\n            emit PriceUpdated(config.symbolHash, anchorPrice);\n        } else if (isWithinAnchor(reportedPrice, anchorPrice)) {\n            require(reportedPrice < 2**248, \"Reported too big\");\n            prices[config.symbolHash].price = uint248(reportedPrice);\n            emit PriceUpdated(config.symbolHash, reportedPrice);\n            valid = true;\n        } else {\n            emit PriceGuarded(config.symbolHash, reportedPrice, anchorPrice);\n        }\n    }\n\n    /// @notice In the event that a feed is failed over to Uniswap TWAP, this function can be called\n    ///         by anyone to update the TWAP price.\n    /// @dev This only works if the feed represented by the symbolHash is failed over, and will revert otherwise\n    /// @param symbolHash bytes32\n    function pokeFailedOverPrice(bytes32 symbolHash) public {\n        PriceData memory priceData = prices[symbolHash];\n        require(priceData.failoverActive, \"Not active\");\n        TokenConfig memory config = getTokenConfigBySymbolHash(symbolHash);\n        uint256 anchorPrice = calculateAnchorPriceFromEthPrice(config);\n        require(anchorPrice < 2**248, \"Anchor too big\");\n        prices[config.symbolHash].price = uint248(anchorPrice);\n        emit PriceUpdated(config.symbolHash, anchorPrice);\n    }\n\n    /// @notice Calculate the anchor price by fetching price data from the TWAP\n    /// @param config TokenConfig\n    /// @return anchorPrice uint\n    function calculateAnchorPriceFromEthPrice(TokenConfig memory config)\n        internal\n        view\n        returns (uint256 anchorPrice)\n    {\n        require(config.priceSource == PriceSource.REPORTER, \"Reporter only\");\n        uint256 ethPrice = fetchEthPrice();\n        if (config.symbolHash == ETH_HASH) {\n            anchorPrice = ethPrice;\n        } else {\n            anchorPrice = fetchAnchorPrice(config, ethPrice);\n        }\n    }\n\n\n    /// @notice Convert the reported price to the 6 decimal format that this view requires\n    /// @param config TokenConfig\n    /// @param reportedPrice from the reporter\n    /// @return convertedPrice uint256\n    function convertReportedPrice(\n        TokenConfig memory config,\n        int256 reportedPrice\n    ) internal pure returns (uint256) {\n        require(reportedPrice >= 0, \"Cant be neg\");\n        uint256 unsignedPrice = uint256(reportedPrice);\n        uint256 convertedPrice = FullMath.mulDiv(\n            unsignedPrice,\n            config.reporterMultiplier,\n            config.baseUnit\n        );\n        return convertedPrice;\n    }\n\n    function isWithinAnchor(uint256 reporterPrice, uint256 anchorPrice)\n        internal\n        view\n        returns (bool)\n    {\n        if (reporterPrice > 0) {\n            uint256 anchorRatio = FullMath.mulDiv(\n                anchorPrice,\n                ETH_BASE_UNIT,\n                reporterPrice\n            );\n            return\n                anchorRatio <= upperBoundAnchorRatio &&\n                anchorRatio >= lowerBoundAnchorRatio;\n        }\n        return false;\n    }\n\n    /// @dev Fetches the latest TWATP from the UniV3 pool oracle, over the last anchor period.\n    ///      Note that the TWATP (time-weighted average tick-price) is not equivalent to the TWAP,\n    ///      as ticks are logarithmic. The TWATP returned by this function will usually\n    ///      be lower than the TWAP.\n    function getUniswapTwap(TokenConfig memory config)\n        internal\n        view\n        returns (uint256)\n    {\n        uint32 anchorPeriod_ = anchorPeriod;\n        uint32[] memory secondsAgos = new uint32[](2);\n        secondsAgos[0] = anchorPeriod_;\n        (int56[] memory tickCumulatives, ) = IUniswapV3Pool(\n            config.uniswapMarket\n        ).observe(secondsAgos);\n\n        int56 anchorPeriod__ = int56(uint56(anchorPeriod_));\n        int56 timeWeightedAverageTickS56 = (tickCumulatives[1] -\n            tickCumulatives[0]) / anchorPeriod__;\n        require(\n            timeWeightedAverageTickS56 >= TickMath.MIN_TICK &&\n                timeWeightedAverageTickS56 <= TickMath.MAX_TICK,\n            \"TWAP not in range\"\n        );\n        require(\n            timeWeightedAverageTickS56 < type(int24).max,\n            \"timeWeightedAverageTick > max\"\n        );\n        int24 timeWeightedAverageTick = int24(timeWeightedAverageTickS56);\n        if (config.isUniswapReversed) {\n            // If the reverse price is desired, inverse the tick\n            // price = 1.0001^{tick}\n            // (price)^{-1} = (1.0001^{tick})^{-1}\n            // \\frac{1}{price} = 1.0001^{-tick}\n            timeWeightedAverageTick = -timeWeightedAverageTick;\n        }\n        uint160 sqrtPriceX96 = TickMath.getSqrtRatioAtTick(\n            timeWeightedAverageTick\n        );\n        // Squaring the result also squares the Q96 scalar (2**96),\n        // so after this mulDiv, the resulting TWAP is still in Q96 fixed precision.\n        uint256 twapX96 = FullMath.mulDiv(\n            sqrtPriceX96,\n            sqrtPriceX96,\n            FixedPoint96.Q96\n        );\n\n        // Scale up to a common precision (EXP_SCALE), then down-scale from Q96.\n        return FullMath.mulDiv(EXP_SCALE, twapX96, FixedPoint96.Q96);\n    }\n\n    /// @dev Fetches the current eth/usd price from Uniswap, with 6 decimals of precision.\n    /// Conversion factor is 1e18 for eth/usdc market, since we decode Uniswap price statically with 18 decimals.\n    function fetchEthPrice() internal view returns (uint256) {      // @todo replace with chainlink pricefeed\n        return uint256(getChainLinkPrice(baseAssetFeed)) / baseAssetFeedDenominator;\n    }\n\n    /// @dev Fetches the current token/usd price from Uniswap, with 6 decimals of precision.\n    /// @param conversionFactor 1e18 if seeking the ETH price, and a 6 decimal ETH-USDC price in the case of other assets\n    function fetchAnchorPrice(\n        TokenConfig memory config,\n        uint256 conversionFactor\n    ) internal view virtual returns (uint256) {\n        // `getUniswapTwap(config)`\n        //      -> TWAP between the baseUnits of Uniswap pair (scaled to 1e18)\n        // `twap * config.baseUnit`\n        //      -> price of 1 token relative to `baseUnit` of the other token (scaled to 1e18)\n        uint256 twap = getUniswapTwap(config);\n\n        // `unscaledPriceMantissa * config.baseUnit / EXP_SCALE`\n        //      -> price of 1 token relative to baseUnit of the other token (scaled to 1)\n        uint256 unscaledPriceMantissa = twap * conversionFactor;\n\n        // Adjust twap according to the units of the non-ETH asset\n        // 1. In the case of ETH, we would have to scale by 1e6 / USDC_UNITS, but since baseUnit2 is 1e6 (USDC), it cancels\n        // 2. In the case of non-ETH tokens\n        //  a. `getUniswapTwap(config)` handles \"reversed\" token pairs, so `twap` will always be Token/ETH TWAP.\n        //  b. conversionFactor = ETH price * 1e6\n        //      unscaledPriceMantissa = twap{token/ETH} * EXP_SCALE * conversionFactor\n        //      so ->\n        //      anchorPrice = (twap * tokenBaseUnit / ETH_BASE_UNIT) * ETH_price * 1e6\n        //                  = twap * conversionFactor * tokenBaseUnit / ETH_BASE_UNIT\n        //                  = unscaledPriceMantissa / EXP_SCALE * tokenBaseUnit / ETH_BASE_UNIT\n        uint256 anchorPrice = (unscaledPriceMantissa * config.baseUnit) /\n            ETH_BASE_UNIT /\n            EXP_SCALE;\n\n        return anchorPrice;\n    }\n\n    /// @notice Activate failover, and fall back to using failover directly.\n    /// @dev Only the owner can call this function\n    function activateFailover(bytes32 symbolHash) external onlyOwner {\n        require(!prices[symbolHash].failoverActive, \"Already active\");\n        TokenConfig memory config = getTokenConfigBySymbolHash(symbolHash);\n        require(config.priceSource == PriceSource.REPORTER, \"Not reporter\");\n        prices[symbolHash].failoverActive = true;\n        emit FailoverActivated(symbolHash);\n        pokeFailedOverPrice(symbolHash);\n    }\n\n    /// @notice Deactivate a previously activated failover\n    /// @dev Only the owner can call this function\n    function deactivateFailover(bytes32 symbolHash) external onlyOwner {\n        require(prices[symbolHash].failoverActive, \"Not active\");\n        prices[symbolHash].failoverActive = false;\n        emit FailoverDeactivated(symbolHash);\n    }\n\n    function hasTwapForAsset(address cToken) internal view returns (bool) {\n        return cTokenConfig[cToken].underlying != address(0);\n    }\n\n    /* ChainLink Oracles */\n\n    function _setPriceFeedForUnderlying(address _underlying, address _chainlinkFeed, uint8 _priceFeedDecimals) onlyOwner external {\n        _setPriceFeedForUnderlyingInternal(_underlying, _chainlinkFeed, _priceFeedDecimals);\n    }\n\n    function _setPriceFeedsForUnderlyings(address[] calldata _underlyings, address[] calldata _chainlinkFeeds, uint8[] calldata _priceFeedsDecimals) onlyOwner external {\n        require(_underlyings.length == _chainlinkFeeds.length, \"invalid lengths\");\n        require(_underlyings.length == _priceFeedsDecimals.length, \"invalid lengths\");\n\n        for (uint i = 0; i < _underlyings.length; i++) {\n            _setPriceFeedForUnderlyingInternal(_underlyings[i], _chainlinkFeeds[i], _priceFeedsDecimals[i]);\n        }\n    }\n\n    function _setPriceFeedForUnderlyingInternal(address underlying, address chainlinkFeed, uint8 priceFeedDecimals) internal {\n        address existingFeed = chainLinkFeeds[underlying];\n        // require(existingFeed == address(0), \"Cannot reassign feed\");\n\n        uint8 decimalsForAsset;\n\n        if (underlying == address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)) {\n            decimalsForAsset = 18;\n        } else {\n            decimalsForAsset = IERC20(underlying).decimals();\n        }\n\n        // Update if the feed is different\n        if (existingFeed != chainlinkFeed) {\n            chainLinkFeeds[underlying] = chainlinkFeed;\n            chainLinkFeedDecimals[underlying] = priceFeedDecimals;\n            assetsDecimals[underlying] = decimalsForAsset;\n            emit NewFeedForAsset(underlying, existingFeed, chainlinkFeed);\n        }\n    }\n\n    function hasFeedForAsset(address asset) public view returns (bool) {\n        return chainLinkFeeds[asset] != address(0);\n    }\n\n    /**\n      * @notice Get the underlying price of a cToken asset\n      * @param asset The asset (Erc20 or native)\n      * @return The asset price mantissa (scaled by 1e(36 - assetDecimals)).\n      *  Zero means the price is unavailable.\n      */\n    function _getOraclePriceForAssetInternal(address asset) internal view returns (uint) {\n        uint8 feedDecimals = chainLinkFeedDecimals[asset];\n        uint8 assetDecimals = assetsDecimals[asset];\n        address feed = chainLinkFeeds[asset];\n        int feedPriceRaw = getChainLinkPrice(AggregatorV3Interface(feed));\n        uint feedPrice = uint(feedPriceRaw);\n\n        // Safety\n        require(feedPriceRaw == int(feedPrice), \"Price Conversion error\");\n\n        // Needs to be scaled to e36 and then divided by the asset's decimals\n        if (feedDecimals == 8) {\n            return (1e28 * feedPrice) / (10 ** assetDecimals);\n        } else if (feedDecimals == 18) {\n            return (1e18 * feedPrice) / (10 ** assetDecimals);\n        } else {\n            return 0;\n        }\n    }\n\n    function getChainLinkPrice(AggregatorV3Interface priceFeed) internal view returns (int) {\n        (\n        uint80 roundID,\n        int price,\n        uint startedAt,\n        uint timeStamp,\n        uint80 answeredInRound\n        ) = priceFeed.latestRoundData();\n        return price;\n    }\n\n    /// @notice         Evaluates input amount according to stored price, accrues interest\n    /// @param cToken   Market to evaluate\n    /// @param amount   Amount of tokens to evaluate according to 'reverse' order\n    /// @param reverse  Order of evaluation\n    /// @return         Depending on 'reverse' order:\n    ///                     false - return USD amount equal to 'amount' of 'cToken' in wei\n    ///                     true - return cTokens equal to 'amount' of USD represented in wei\n    ///                            e.g. 123e18 = 123.00$\n    function getEvaluation(ICToken cToken, uint256 amount, bool reverse) external returns (uint256) {\n        Exp memory exchangeRate = Exp({mantissa: cToken.exchangeRateCurrent()});\n        uint256 oraclePriceMantissa = getUnderlyingPrice(cToken);        \n        require(oraclePriceMantissa != 0, \"invalid price\");\n        Exp memory oraclePrice = Exp({mantissa: oraclePriceMantissa});\n\n        if (reverse) {\n            // input: 'amount' in USD scaled in 1e18, i.e. 19.54$ = 19540000000000000000\n            // tokenAmount = amountUSD / oraclePrice \n            // cTokenAmount = tokenAmount / exchangeRate\n            uint256 tokenAmount = div_(amount, oraclePrice);\n            uint256 cTokenAmount =  div_(tokenAmount, exchangeRate);\n            return cTokenAmount; \n        }\n        // underlyingAmount = exchangeRate * cTokenAmount\n        // underlyingAmountUSD = underlyingAmount * oraclePrice\n        uint256 underlyingAmount = mul_ScalarTruncate(exchangeRate, amount);\n        uint256 underlyingAmountUSD = mul_ScalarTruncate(oraclePrice, underlyingAmount);\n        return underlyingAmountUSD;\n    }\n\n\n    /// @notice         Evaluates input amount according to stored price, doesn't accrue interest\n    /// @param cToken   Market to evaluate\n    /// @param amount   Amount of tokens to evaluate according to 'reverse' order\n    /// @param reverse  Order of evaluation\n    /// @return         Depending on 'reverse' order:\n    ///                     false - return USD amount equal to 'amount' of 'cToken' in wei\n    ///                     true - return cTokens equal to 'amount' of USD represented in wei\n    ///                            e.g. 123e18 = 123.00$\n    function getEvaluationStored(ICToken cToken, uint256 amount, bool reverse) external view returns (uint256) {\n        Exp memory exchangeRate = Exp({mantissa: cToken.exchangeRateStored()});\n        // uint256 underlyingDecimals = IERC20(cToken.underlying()).decimals();\n        uint256 oraclePriceMantissa = getUnderlyingPrice(cToken);\n        require(oraclePriceMantissa != 0, \"invalid price\");\n        Exp memory oraclePrice = Exp({mantissa: oraclePriceMantissa});\n\n        if (reverse) {\n            // input: 'amount' in USD scaled in 1e18, i.e. 19.54$ = 19540000000000000000\n            // tokenAmount = amountUSD / oraclePrice \n            // cTokenAmount = tokenAmount / exchangeRate\n            uint256 tokenAmount = div_(amount, oraclePrice);\n            uint256 cTokenAmount =  div_(tokenAmount, exchangeRate);\n            return cTokenAmount; \n        }\n        // underlyingAmount = exchangeRate * cTokenAmount\n        // underlyingAmountUSD = underlyingAmount * oraclePrice\n        uint256 underlyingAmount = mul_ScalarTruncate(exchangeRate, amount);\n        uint256 underlyingAmountUSD = mul_ScalarTruncate(oraclePrice, underlyingAmount);\n        return underlyingAmountUSD;\n    }\n}\n"
    },
    "contracts/Oracles/UniswapConfigV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/IPriceOracle.sol\";\nimport \"./UniswapLib.sol\";\n\n\ncontract UniswapConfigV2 is Ownable {\n\n    /// @dev Describe how to interpret the fixedPrice in the TokenConfig.\n    enum PriceSource {\n        FIXED_ETH, /// implies the fixedPrice is a constant multiple of the ETH price (which varies)\n        FIXED_USD, /// implies the fixedPrice is a constant multiple of the USD price (which is 1)\n        REPORTER /// implies the price is set by the reporter\n    }\n\n    /// @dev Describe how the USD price should be determined for an asset.\n    struct TokenConfig {\n        // The address of the Compound Token\n        address cToken;\n        // The address of the underlying market token. For this `LINK` market configuration, this would be the address of the `LINK` token.\n        address underlying;\n        // The bytes32 hash of the underlying symbol.\n        bytes32 symbolHash;\n        // The number of smallest units of measurement in a single whole unit.\n        uint256 baseUnit;\n        // Where price is coming from.  Refer to README for more information\n        PriceSource priceSource;\n        // The fixed price multiple of either ETH or USD, depending on the `priceSource`. If `priceSource` is `reporter`, this is unused.\n        uint256 fixedPrice;\n        // The address of the pool being used as the anchor for this market.\n        address uniswapMarket;\n        // The address of the `ValidatorProxy` acting as the reporter\n        address reporter;\n        // Prices reported by a `ValidatorProxy` must be transformed to 6 decimals for the UAV.  This is the multiplier to convert the reported price to 6dp\n        uint256 reporterMultiplier;\n        // True if the pair on Uniswap is defined as ETH / X\n        bool isUniswapReversed;\n    }\n\n    /// @notice cToken configs\n    mapping(address => TokenConfig) public cTokenConfig;\n    \n    /// @notice cToken address by reporter address\n    mapping(address => address) internal cTokenByReporter;\n\n    /// @notice cToken address by underlying's symbol hash\n    mapping(bytes32 => address) internal cTokenBySymbolHash;\n\n    /// @notice cToken address by underlying address\n    mapping(address => address) internal cTokenByUnderlying;\n\n    event ConfigUpdate(address indexed cToken, address uniswapMarket);\n\n    /**\n     * @notice Sets config to fetch underlying price\n     * @param cToken The address of the Compound Token\n     * @param priceSource Type of the price source\n     * @param uniswapMarket The address of the pool being used as the anchor for this market\n     * @param reporter The address of the `ValidatorProxy` acting as the reporter\n     * @param reporterMultiplier Prices reported by a `ValidatorProxy` must be transformed to 6 decimals for the UAV\n     */\n    function setTokenConfig(\n        address cToken,\n        PriceSource priceSource,\n        uint256 fixedPrice,\n        address uniswapMarket,\n        address reporter,\n        uint256 reporterMultiplier\n        ) external onlyOwner {\n\n        require(ICToken(cToken).isCToken(), \"invalid cToken\");\n        address underlying = ICToken(cToken).underlying();\n\n        if (priceSource == PriceSource.REPORTER) {\n            require(uniswapMarket != address(0), \"No anchor\");\n            require(reporter != address(0), \"No reporter\");\n            // require(\n            //     IUniswapV3Pool(uniswapMarket).token0() == underlying || \n            //     IUniswapV3Pool(uniswapMarket).token1() == underlying,\n            //     \"invalid market\"\n            //     );\n        } else {\n            require(uniswapMarket == address(0), \"Doesnt need anchor\");\n            require(reporter == address(0), \"Doesnt need reporter\");\n        }\n        // @todo prevent same reporter for different cTokens?\n\n        bytes32 symbolHash = keccak256(bytes(IERC20(underlying).symbol()));\n        uint256 baseUnit = 10 ** IERC20(underlying).decimals();\n        // bool isUniswapReversed = IUniswapV3Pool(uniswapMarket).token0() == underlying ?\n        //     false : true;\n        bool isUniswapReversed = false;\n\n        cTokenConfig[cToken] = TokenConfig({\n            cToken: address(cToken),\n            underlying: underlying,\n            symbolHash: symbolHash,\n            baseUnit: baseUnit,\n            priceSource: priceSource,\n            fixedPrice: fixedPrice,\n            uniswapMarket: uniswapMarket,\n            reporter: reporter,\n            reporterMultiplier: reporterMultiplier,\n            isUniswapReversed: isUniswapReversed\n        });\n\n        cTokenByReporter[reporter] = cToken;\n        cTokenBySymbolHash[symbolHash] = cToken;\n        cTokenByUnderlying[underlying] = cToken;\n        \n        emit ConfigUpdate(cToken, uniswapMarket);\n    }\n\n    /**\n     * @notice Get the config for symbol\n     * @param symbol The symbol of the config to get\n     * @return The config object\n     */\n    function getTokenConfigBySymbol(string calldata symbol)\n        public\n        view\n        returns (TokenConfig memory)\n    {\n        TokenConfig memory config = cTokenConfig[cTokenBySymbolHash[keccak256(bytes(symbol))]];\n        return config;\n    }\n\n    /**\n     * @notice Get the config for the symbolHash\n     * @param symbolHash The keccack256 of the symbol of the config to get\n     * @return The config object\n     */\n    function getTokenConfigBySymbolHash(bytes32 symbolHash)\n        public\n        view\n        returns (TokenConfig memory)\n    {\n        TokenConfig memory config = cTokenConfig[cTokenBySymbolHash[symbolHash]];\n        return config;\n    }\n\n    /**\n     * @notice Get the config for the reporter\n     * @param reporter The address of the reporter of the config to get\n     * @return The config object\n     */\n    function getTokenConfigByReporter(address reporter)\n        public\n        view\n        returns (TokenConfig memory)\n    {\n        TokenConfig memory config = cTokenConfig[cTokenByReporter[reporter]];\n        return config;\n    }\n\n    /**\n     * @notice Get the config for the cToken\n     * @param cToken The address of the cToken of the config to get\n     * @return The config object\n     */\n    function getTokenConfigByCToken(address cToken)\n        public\n        view\n        returns (TokenConfig memory)\n    {\n        TokenConfig memory config = cTokenConfig[cToken];\n        return config;\n    }\n\n    /**\n     * @notice Get the config for an underlying asset\n     * @dev The underlying address of ETH is the zero address\n     * @param underlying The address of the underlying asset of the config to get\n     * @return The config object\n     */\n    function getTokenConfigByUnderlying(address underlying)\n        public\n        view\n        returns (TokenConfig memory)\n    {\n        TokenConfig memory config = cTokenConfig[cTokenByUnderlying[underlying]];\n        return config;\n    }\n}"
    },
    "contracts/Oracles/UniswapLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >0.8.7;\n\n// From: https://github.com/Uniswap/uniswap-v3-core\n\n/// @title FixedPoint96\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\n/// @dev Used in SqrtPriceMath.sol\nlibrary FixedPoint96 {\n    uint8 internal constant RESOLUTION = 96;\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\n}\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = a * b\n        // Compute the product mod 2**256 and mod 2**256 - 1\n        // then use the Chinese Remainder Theorem to reconstruct\n        // the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2**256 + prod0\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(a, b, not(0))\n            prod0 := mul(a, b)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division\n        if (prod1 == 0) {\n            require(denominator > 0);\n            assembly {\n                result := div(prod0, denominator)\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2**256.\n        // Also prevents denominator == 0\n        require(denominator > prod1);\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0]\n        // Compute remainder using mulmod\n        uint256 remainder;\n        assembly {\n            remainder := mulmod(a, b, denominator)\n        }\n        // Subtract 256 bit number from 512 bit number\n        assembly {\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator\n        // Compute largest power of two divisor of denominator.\n        // Always >= 1.\n        uint256 twos = denominator & (~denominator + 1);\n        // Divide denominator by power of two\n        assembly {\n            denominator := div(denominator, twos)\n        }\n\n        // Divide [prod1 prod0] by the factors of two\n        assembly {\n            prod0 := div(prod0, twos)\n        }\n        // Shift in bits from prod1 into prod0. For this we need\n        // to flip `twos` such that it is 2**256 / twos.\n        // If twos is zero, then it becomes one\n        assembly {\n            twos := add(div(sub(0, twos), twos), 1)\n        }\n        prod0 |= prod1 * twos;\n\n        // Invert denominator mod 2**256\n        // Now that denominator is an odd number, it has an inverse\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n        // Compute the inverse by starting with a seed that is correct\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\n        uint256 inv = (3 * denominator) ^ 2;\n        // Now use Newton-Raphson iteration to improve the precision.\n        // Thanks to Hensel's lifting lemma, this also works in modular\n        // arithmetic, doubling the correct bits in each step.\n        inv *= 2 - denominator * inv; // inverse mod 2**8\n        inv *= 2 - denominator * inv; // inverse mod 2**16\n        inv *= 2 - denominator * inv; // inverse mod 2**32\n        inv *= 2 - denominator * inv; // inverse mod 2**64\n        inv *= 2 - denominator * inv; // inverse mod 2**128\n        inv *= 2 - denominator * inv; // inverse mod 2**256\n\n        // Because the division is now exact we can divide by multiplying\n        // with the modular inverse of denominator. This will give us the\n        // correct result modulo 2**256. Since the precoditions guarantee\n        // that the outcome is less than 2**256, this is the final result.\n        // We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = prod0 * inv;\n        return result;\n    }\n}\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n    int24 internal constant MIN_TICK = -887272;\n    int24 internal constant MAX_TICK = -MIN_TICK;\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO =\n        1461446703485210103287273052203988822378723970342;\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n    /// at the given tick\n    function getSqrtRatioAtTick(int24 tick)\n        internal\n        pure\n        returns (uint160 sqrtPriceX96)\n    {\n        uint256 absTick = tick < 0\n            ? uint256(-int256(tick))\n            : uint256(int256(tick));\n        require(absTick <= uint256(uint24(MAX_TICK)), \"T\");\n\n        uint256 ratio = absTick & 0x1 != 0\n            ? 0xfffcb933bd6fad37aa2d162d1a594001\n            : 0x100000000000000000000000000000000;\n        if (absTick & 0x2 != 0)\n            ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n        if (absTick & 0x4 != 0)\n            ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n        if (absTick & 0x8 != 0)\n            ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n        if (absTick & 0x10 != 0)\n            ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n        if (absTick & 0x20 != 0)\n            ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n        if (absTick & 0x40 != 0)\n            ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n        if (absTick & 0x80 != 0)\n            ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n        if (absTick & 0x100 != 0)\n            ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n        if (absTick & 0x200 != 0)\n            ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n        if (absTick & 0x400 != 0)\n            ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n        if (absTick & 0x800 != 0)\n            ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n        if (absTick & 0x1000 != 0)\n            ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n        if (absTick & 0x2000 != 0)\n            ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n        if (absTick & 0x4000 != 0)\n            ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n        if (absTick & 0x8000 != 0)\n            ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n        if (absTick & 0x10000 != 0)\n            ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n        if (absTick & 0x20000 != 0)\n            ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n        if (absTick & 0x40000 != 0)\n            ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n        if (absTick & 0x80000 != 0)\n            ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n        if (tick > 0) ratio = type(uint256).max / ratio;\n\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n        sqrtPriceX96 = uint160(\n            (ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1)\n        );\n    }\n}\n\ninterface IUniswapV3Pool {\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n    /// you must call it with secondsAgos = [3600, 0].\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n    /// timestamp\n    function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        returns (\n            int56[] memory tickCumulatives,\n            uint160[] memory secondsPerLiquidityCumulativeX128s\n        );\n\n    /// @notice Swap token0 for token1, or token1 for token0\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n    /// @param recipient The address to receive the output of the swap\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n    /// @param data Any data to be passed through to the callback\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n}\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n\ninterface IERC20 {\n\n    function decimals() external view returns (uint8);\n    function symbol() external view returns (string memory);\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool success);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}